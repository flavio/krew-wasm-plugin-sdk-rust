<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A library for consistent and reliable error handling"><meta name="keywords" content="rust, rustlang, rust-lang, error_chain"><title>error_chain - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../dark.css" disabled><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script src="../crates.js"></script><script defer src="../main.js"></script>
    <noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../error_chain/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../error_chain/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">Crate error_chain</a></h2><div class="sidebar-elems"><div class="block"><ul><li class="version">Version 0.12.4</li><li><a id="all-types" href="all.html">All Items</a></li></div></ul><section><div class="block"><ul><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li></ul></div></section><div id="sidebar-vars" data-name="error_chain" data-ty="mod" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../error_chain/index.html"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="22" height="22" alt="Pick another theme!" src="../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">error_chain</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../src/error_chain/lib.rs.html#1-824">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A library for consistent and reliable error handling</p>
<p>error-chain makes it easy to take full advantage of Rust’s
powerful error handling features without the overhead of
maintaining boilerplate error types and conversions. It implements
an opinionated strategy for defining your own error types, as well
as conversions from others’ error types.</p>
<h3 id="quick-start"><a href="#quick-start">Quick start</a></h3>
<p>If you just want to set up your new project with error-chain,
follow the <a href="https://github.com/rust-lang-nursery/error-chain/blob/master/examples/quickstart.rs">quickstart.rs</a> template, and read this <a href="http://brson.github.io/2016/11/30/starting-with-error-chain">intro</a>
to error-chain.</p>
<h3 id="why-error-chain"><a href="#why-error-chain">Why error chain?</a></h3>
<ul>
<li>error-chain is easy to configure. Handle errors robustly with minimal
effort.</li>
<li>Basic error handling requires no maintenance of custom error types
nor the <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> conversions that make <code>?</code> work.</li>
<li>error-chain scales from simple error handling strategies to more
rigorous.  Return formatted strings for simple errors, only
introducing error variants and their strong typing as needed for
advanced error recovery.</li>
<li>error-chain makes it trivial to correctly manage the <a href="https://doc.rust-lang.org/std/error/trait.Error.html#method.cause">cause</a> of
the errors generated by your own code. This is the “chaining”
in “error-chain”.</li>
</ul>
<h3 id="principles-of-error-chain"><a href="#principles-of-error-chain">Principles of error-chain</a></h3>
<p>error-chain is based on the following principles:</p>
<ul>
<li>No error should ever be discarded. This library primarily
makes it easy to “chain” errors with the <a href="example_generated/trait.ResultExt.html#tymethod.chain_err"><code>chain_err</code></a> method.</li>
<li>Introducing new errors is trivial. Simple errors can be introduced
at the error site with just a string.</li>
<li>Handling errors is possible with pattern matching.</li>
<li>Conversions between error types are done in an automatic and
consistent way - <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> conversion behavior is never specified
explicitly.</li>
<li>Errors implement <a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>.</li>
<li>Errors can carry backtraces.</li>
</ul>
<p>Similar to other libraries like <a href="https://github.com/DanielKeep/rust-error-type">error-type</a> and <a href="https://github.com/tailhook/quick-error">quick-error</a>,
this library introduces the error chaining mechanism originally
employed by Cargo.  The <a href="macro.error_chain.html"><code>error_chain!</code></a> macro declares the types
and implementation boilerplate necessary for fulfilling a
particular error-handling strategy. Most importantly it defines a
custom error type (called <a href="example_generated/struct.Error.html"><code>Error</code></a> by convention) and the <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a>
conversions that let the <code>?</code> operator work.</p>
<p>This library differs in a few ways from previous error libs:</p>
<ul>
<li>Instead of defining the custom <a href="example_generated/struct.Error.html"><code>Error</code></a> type as an enum, it is a
struct containing an <a href="example_generated/enum.ErrorKind.html"><code>ErrorKind</code></a> (which defines the
<a href="example_generated/enum.ErrorKind.html#method.description"><code>description</code></a> and <a href="trait.ChainedError.html#method.display_chain"><code>display_chain</code></a> methods for the error), an opaque,
optional, boxed <a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>std::error::Error</code></a><code>+</code><a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a><code> + 'static</code> object
(which defines the <a href="example_generated/struct.Error.html#method.cause"><code>cause</code></a>, and establishes the links in the
error chain), and a <a href="struct.Backtrace.html"><code>Backtrace</code></a>.</li>
<li>The macro also defines a <a href="example_generated/trait.ResultExt.html"><code>ResultExt</code></a> trait that defines a
<a href="example_generated/trait.ResultExt.html#tymethod.chain_err"><code>chain_err</code></a> method. This method on all <a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>std::error::Error</code></a><code>+</code><a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a><code> + 'static</code>
types extends the error chain by boxing the current
error into an opaque object and putting it inside a new concrete
error.</li>
<li>It provides automatic <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> conversions between other error types
defined by the <a href="macro.error_chain.html"><code>error_chain!</code></a> that preserve type information,
and facilitate seamless error composition and matching of composed
errors.</li>
<li>It provides automatic <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> conversions between any other error
type that hides the type of the other error in the <a href="example_generated/struct.Error.html#method.cause"><code>cause</code></a> box.</li>
<li>If <code>RUST_BACKTRACE</code> is enabled, it collects a single backtrace at
the earliest opportunity and propagates it down the stack through
<a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> and <a href="example_generated/trait.ResultExt.html"><code>ResultExt</code></a> conversions.</li>
</ul>
<p>To accomplish its goals it makes some tradeoffs:</p>
<ul>
<li>The split between the <a href="example_generated/struct.Error.html"><code>Error</code></a> and <a href="example_generated/enum.ErrorKind.html"><code>ErrorKind</code></a> types can make it
slightly more cumbersome to instantiate new (unchained) errors,
requiring an <a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a> or <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> conversion; as well as slightly
more cumbersome to match on errors with another layer of types
to match.</li>
<li>Because the error type contains <a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>std::error::Error</code></a><code>+</code><a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a><code> + 'static</code> objects,
it can’t implement <a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a> for easy comparisons.</li>
</ul>
<h3 id="declaring-error-types"><a href="#declaring-error-types">Declaring error types</a></h3>
<p>Generally, you define one family of error types per crate, though
it’s also perfectly fine to define error types on a finer-grained
basis, such as per module.</p>
<p>Assuming you are using crate-level error types, typically you will
define an <code>errors</code> module and inside it call <a href="macro.error_chain.html"><code>error_chain!</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">mod</span> <span class="ident">other_error</span> {
    <span class="macro">error_chain!</span> {}
}

<span class="macro">error_chain!</span> {
    <span class="comment">// The type defined for this error. These are the conventional</span>
    <span class="comment">// and recommended names, but they can be arbitrarily chosen.</span>
    <span class="comment">//</span>
    <span class="comment">// It is also possible to leave this section out entirely, or</span>
    <span class="comment">// leave it empty, and these names will be used automatically.</span>
    <span class="ident">types</span> {
        <span class="ident">Error</span>, <span class="ident">ErrorKind</span>, <span class="ident">ResultExt</span>, <span class="prelude-ty">Result</span>;
    }

    <span class="comment">// Without the `Result` wrapper:</span>
    <span class="comment">//</span>
    <span class="comment">// types {</span>
    <span class="comment">//     Error, ErrorKind, ResultExt;</span>
    <span class="comment">// }</span>

    <span class="comment">// Automatic conversions between this error chain and other</span>
    <span class="comment">// error chains. In this case, it will e.g. generate an</span>
    <span class="comment">// `ErrorKind` variant called `Another` which in turn contains</span>
    <span class="comment">// the `other_error::ErrorKind`, with conversions from</span>
    <span class="comment">// `other_error::Error`.</span>
    <span class="comment">//</span>
    <span class="comment">// Optionally, some attributes can be added to a variant.</span>
    <span class="comment">//</span>
    <span class="comment">// This section can be empty.</span>
    <span class="ident">links</span> {
        <span class="ident">Another</span>(<span class="ident">other_error::Error</span>, <span class="ident">other_error::ErrorKind</span>) <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">unix</span>)]</span>;
    }

    <span class="comment">// Automatic conversions between this error chain and other</span>
    <span class="comment">// error types not defined by the `error_chain!`. These will be</span>
    <span class="comment">// wrapped in a new error with, in the first case, the</span>
    <span class="comment">// `ErrorKind::Fmt` variant. The description and cause will</span>
    <span class="comment">// forward to the description and cause of the original error.</span>
    <span class="comment">//</span>
    <span class="comment">// Optionally, some attributes can be added to a variant.</span>
    <span class="comment">//</span>
    <span class="comment">// This section can be empty.</span>
    <span class="ident">foreign_links</span> {
        <span class="ident">Fmt</span>(<span class="ident">::std::fmt::Error</span>);
        <span class="ident">Io</span>(<span class="ident">::std::io::Error</span>) <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">unix</span>)]</span>;
    }

    <span class="comment">// Define additional `ErrorKind` variants.  Define custom responses with the</span>
    <span class="comment">// `description` and `display` calls.</span>
    <span class="ident">errors</span> {
        <span class="ident">InvalidToolchainName</span>(<span class="ident">t</span>: <span class="ident">String</span>) {
            <span class="ident">description</span>(<span class="string">&quot;invalid toolchain name&quot;</span>)
            <span class="ident">display</span>(<span class="string">&quot;invalid toolchain name: &#39;{}&#39;&quot;</span>, <span class="ident">t</span>)
        }

        <span class="comment">// You can also add commas after description/display.</span>
        <span class="comment">// This may work better with some editor auto-indentation modes:</span>
        <span class="ident">UnknownToolchainVersion</span>(<span class="ident">v</span>: <span class="ident">String</span>) {
            <span class="ident">description</span>(<span class="string">&quot;unknown toolchain version&quot;</span>), <span class="comment">// note the ,</span>
            <span class="ident">display</span>(<span class="string">&quot;unknown toolchain version: &#39;{}&#39;&quot;</span>, <span class="ident">v</span>), <span class="comment">// trailing comma is allowed</span>
        }
    }

    <span class="comment">// If this annotation is left off, a variant `Msg(s: String)` will be added, and `From`</span>
    <span class="comment">// impls will be provided for `String` and `&amp;str`</span>
    <span class="ident">skip_msg_variant</span>
}
</code></pre></div>
<p>Each section, <code>types</code>, <code>links</code>, <code>foreign_links</code>, and <code>errors</code> may
be omitted if it is empty.</p>
<p>This populates the module with a number of definitions,
the most important of which are the <a href="example_generated/struct.Error.html"><code>Error</code></a> type
and the <a href="example_generated/enum.ErrorKind.html"><code>ErrorKind</code></a> type. An example of generated code can be found in the
<a href="example_generated/index.html">example_generated</a> module.</p>
<h3 id="returning-new-errors"><a href="#returning-new-errors">Returning new errors</a></h3>
<p>Introducing new error chains, with a string message:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn</span> <span class="ident">foo</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="prelude-val">Err</span>(<span class="string">&quot;foo error!&quot;</span>.<span class="ident">into</span>())
}</code></pre></div>
<p>Introducing new error chains, with an <a href="example_generated/enum.ErrorKind.html"><code>ErrorKind</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">error_chain!</span> {
    <span class="ident">errors</span> { <span class="ident">FooError</span> }
}

<span class="kw">fn</span> <span class="ident">foo</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="prelude-val">Err</span>(<span class="ident">ErrorKind::FooError</span>.<span class="ident">into</span>())
}</code></pre></div>
<p>Note that the return type is the typedef <a href="example_generated/type.Result.html"><code>Result</code></a>, which is
defined by the macro as <code>pub type Result&lt;T&gt; = ::std::result::Result&lt;T, Error&gt;</code>. Note that in both cases
<a href="https://doc.rust-lang.org/std/convert/trait.Into.html#tymethod.into"><code>.into()</code></a> is called to convert a type into the <a href="example_generated/struct.Error.html"><code>Error</code></a> type; both
strings and <a href="example_generated/enum.ErrorKind.html"><code>ErrorKind</code></a> have <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> conversions to turn them into
<a href="example_generated/struct.Error.html"><code>Error</code></a>.</p>
<p>When the error is emitted behind the <code>?</code> operator, the explicit conversion
isn’t needed; <code>Err(ErrorKind)</code> will automatically be converted to <code>Err(Error)</code>.
So the below is equivalent to the previous:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn</span> <span class="ident">foo</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="prelude-val">Ok</span>(<span class="prelude-val">Err</span>(<span class="ident">ErrorKind::FooError</span>)<span class="question-mark">?</span>)
}

<span class="kw">fn</span> <span class="ident">bar</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="prelude-val">Ok</span>(<span class="prelude-val">Err</span>(<span class="string">&quot;bogus!&quot;</span>)<span class="question-mark">?</span>)
}</code></pre></div>
<h3 id="the-bail-macro"><a href="#the-bail-macro">The <code>bail!</code> macro</a></h3>
<p>The above method of introducing new errors works but is a little
verbose. Instead, we can use the <a href="macro.bail.html"><code>bail!</code></a> macro, which performs an early return
with conversions done automatically.</p>
<p>With <a href="macro.bail.html"><code>bail!</code></a> the previous examples look like:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn</span> <span class="ident">foo</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="kw">if</span> <span class="bool-val">true</span> {
        <span class="macro">bail!</span>(<span class="ident">ErrorKind::FooError</span>);
    } <span class="kw">else</span> {
        <span class="prelude-val">Ok</span>(())
    }
}

<span class="kw">fn</span> <span class="ident">bar</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="kw">if</span> <span class="bool-val">true</span> {
        <span class="macro">bail!</span>(<span class="string">&quot;bogus!&quot;</span>);
    } <span class="kw">else</span> {
        <span class="prelude-val">Ok</span>(())
    }
}</code></pre></div>
<h3 id="chaining-errors"><a href="#chaining-errors">Chaining errors</a></h3>
<p>error-chain supports extending an error chain by appending new errors.
This can be done on a Result or on an existing Error.</p>
<p>To extend the error chain:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">res</span>: <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> <span class="op">=</span> <span class="ident">do_something</span>().<span class="ident">chain_err</span>(<span class="op">|</span><span class="op">|</span> <span class="string">&quot;something went wrong&quot;</span>);</code></pre></div>
<p><a href="example_generated/trait.ResultExt.html#tymethod.chain_err"><code>chain_err</code></a> can be called on any <a href="example_generated/type.Result.html"><code>Result</code></a> type where the contained
error type implements <a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>std::error::Error</code></a><code>+</code><a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a><code> + 'static</code>, as long as
the <a href="example_generated/type.Result.html"><code>Result</code></a> type’s corresponding <a href="example_generated/trait.ResultExt.html"><code>ResultExt</code></a> trait is in scope.  If
the <a href="example_generated/type.Result.html"><code>Result</code></a> is an <code>Err</code> then <a href="example_generated/trait.ResultExt.html#tymethod.chain_err"><code>chain_err</code></a> evaluates the closure,
which returns <em>some type that can be converted to <a href="example_generated/enum.ErrorKind.html"><code>ErrorKind</code></a></em>,
boxes the original error to store as the cause, then returns a new
error containing the original error.</p>
<p>Calling <a href="example_generated/struct.Error.html#method.chain_err"><code>chain_err</code></a> on an existing <a href="example_generated/struct.Error.html"><code>Error</code></a> instance has
the same signature and produces the same outcome as being called on a
<a href="example_generated/type.Result.html"><code>Result</code></a> matching the properties described above. This is most useful when
partially handling errors using the <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.map_err"><code>map_err</code></a> function.</p>
<p>To chain an error directly, use <a href="example_generated/struct.Error.html#method.with_chain"><code>with_chain</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">res</span>: <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> <span class="op">=</span>
    <span class="ident">do_something</span>().<span class="ident">map_err</span>(<span class="op">|</span><span class="ident">e</span><span class="op">|</span> <span class="ident">Error::with_chain</span>(<span class="ident">e</span>, <span class="string">&quot;something went wrong&quot;</span>));</code></pre></div>
<h3 id="linking-errors"><a href="#linking-errors">Linking errors</a></h3>
<p>To convert an error from another error chain to this error chain:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">error_chain!</span> {
    <span class="ident">links</span> {
        <span class="ident">OtherError</span>(<span class="ident">other::Error</span>, <span class="ident">other::ErrorKind</span>);
    }
}

<span class="kw">fn</span> <span class="ident">do_other_thing</span>() -&gt; <span class="ident">other::Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> { <span class="macro">unimplemented!</span>() }

<span class="kw">let</span> <span class="ident">res</span>: <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> <span class="op">=</span> <span class="ident">do_other_thing</span>().<span class="ident">map_err</span>(<span class="op">|</span><span class="ident">e</span><span class="op">|</span> <span class="ident">e</span>.<span class="ident">into</span>());</code></pre></div>
<p>The <a href="example_generated/struct.Error.html"><code>Error</code></a> and <a href="example_generated/enum.ErrorKind.html"><code>ErrorKind</code></a> types implements <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> for the corresponding
types of all linked error chains. Linked errors do not introduce a new
cause to the error chain.</p>
<h3 id="matching-errors"><a href="#matching-errors">Matching errors</a></h3>
<p>error-chain error variants are matched with simple patterns.
<a href="example_generated/struct.Error.html"><code>Error</code></a> is a tuple struct and its first field is the <a href="example_generated/enum.ErrorKind.html"><code>ErrorKind</code></a>,
making dispatching on error kinds relatively compact:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">error_chain!</span> {
    <span class="ident">errors</span> {
        <span class="ident">InvalidToolchainName</span>(<span class="ident">t</span>: <span class="ident">String</span>) {
            <span class="ident">description</span>(<span class="string">&quot;invalid toolchain name&quot;</span>)
            <span class="ident">display</span>(<span class="string">&quot;invalid toolchain name: &#39;{}&#39;&quot;</span>, <span class="ident">t</span>)
        }
    }
}

<span class="kw">match</span> <span class="ident">Error::from</span>(<span class="string">&quot;error!&quot;</span>) {
    <span class="ident">Error</span>(<span class="ident">ErrorKind::InvalidToolchainName</span>(<span class="kw">_</span>), <span class="kw">_</span>) =&gt; { }
    <span class="ident">Error</span>(<span class="ident">ErrorKind::Msg</span>(<span class="kw">_</span>), <span class="kw">_</span>) =&gt; { }
    <span class="kw">_</span> =&gt; { }
}</code></pre></div>
<p>Chained errors are also matched with (relatively) compact syntax</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">mod</span> <span class="ident">utils</span> {
    <span class="macro">error_chain!</span> {
        <span class="ident">errors</span> {
            <span class="ident">BadStuff</span> {
                <span class="ident">description</span>(<span class="string">&quot;bad stuff&quot;</span>)
            }
        }
    }
}

<span class="kw">mod</span> <span class="ident">app</span> {
    <span class="macro">error_chain!</span> {
        <span class="ident">links</span> {
            <span class="ident">Utils</span>(<span class="ident">::utils::Error</span>, <span class="ident">::utils::ErrorKind</span>);
        }
    }
}


<span class="kw">match</span> <span class="ident">app::Error::from</span>(<span class="string">&quot;error!&quot;</span>) {
    <span class="ident">app::Error</span>(<span class="ident">app::ErrorKind::Utils</span>(<span class="ident">utils::ErrorKind::BadStuff</span>), <span class="kw">_</span>) =&gt; { }
    <span class="kw">_</span> =&gt; { }
}</code></pre></div>
<h3 id="inspecting-errors"><a href="#inspecting-errors">Inspecting errors</a></h3>
<p>An error-chain error contains information about the error itself, a backtrace, and the chain
of causing errors. For reporting purposes, this information can be accessed as follows.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">error_chain::ChainedError</span>;  <span class="comment">// for e.display_chain()</span>

<span class="macro">error_chain!</span> {
    <span class="ident">errors</span> {
        <span class="ident">InvalidToolchainName</span>(<span class="ident">t</span>: <span class="ident">String</span>) {
            <span class="ident">description</span>(<span class="string">&quot;invalid toolchain name&quot;</span>)
            <span class="ident">display</span>(<span class="string">&quot;invalid toolchain name: &#39;{}&#39;&quot;</span>, <span class="ident">t</span>)
        }
    }
}

<span class="comment">// Generate an example error to inspect:</span>
<span class="kw">let</span> <span class="ident">e</span> <span class="op">=</span> <span class="string">&quot;xyzzy&quot;</span>.<span class="ident">parse</span>::<span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>()
    .<span class="ident">chain_err</span>(<span class="op">|</span><span class="op">|</span> <span class="ident">ErrorKind::InvalidToolchainName</span>(<span class="string">&quot;xyzzy&quot;</span>.<span class="ident">to_string</span>()))
    .<span class="ident">unwrap_err</span>();

<span class="comment">// Get the brief description of the error:</span>
<span class="macro">assert_eq!</span>(<span class="ident">e</span>.<span class="ident">description</span>(), <span class="string">&quot;invalid toolchain name&quot;</span>);

<span class="comment">// Get the display version of the error:</span>
<span class="macro">assert_eq!</span>(<span class="ident">e</span>.<span class="ident">to_string</span>(), <span class="string">&quot;invalid toolchain name: &#39;xyzzy&#39;&quot;</span>);

<span class="comment">// Get the full cause and backtrace:</span>
<span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">e</span>.<span class="ident">display_chain</span>().<span class="ident">to_string</span>());
<span class="comment">//     Error: invalid toolchain name: &#39;xyzzy&#39;</span>
<span class="comment">//     Caused by: invalid digit found in string</span>
<span class="comment">//     stack backtrace:</span>
<span class="comment">//        0:     0x7fa9f684fc94 - backtrace::backtrace::libunwind::trace</span>
<span class="comment">//                             at src/backtrace/libunwind.rs:53</span>
<span class="comment">//                              - backtrace::backtrace::trace&lt;closure&gt;</span>
<span class="comment">//                             at src/backtrace/mod.rs:42</span>
<span class="comment">//        1:     0x7fa9f6850b0e - backtrace::capture::{{impl}}::new</span>
<span class="comment">//                             at out/capture.rs:79</span>
<span class="comment">//     [..]</span></code></pre></div>
<p>The <a href="example_generated/struct.Error.html"><code>Error</code></a> and <a href="example_generated/enum.ErrorKind.html"><code>ErrorKind</code></a> types also allow programmatic access to these elements.</p>
<h3 id="foreign-links"><a href="#foreign-links">Foreign links</a></h3>
<p>Errors that do not conform to the same conventions as this library
can still be included in the error chain. They are considered “foreign
errors”, and are declared using the <code>foreign_links</code> block of the
<a href="macro.error_chain.html"><code>error_chain!</code></a> macro. <a href="example_generated/struct.Error.html"><code>Error</code></a>s are automatically created from
foreign errors by the <code>?</code> operator.</p>
<p>Foreign links and regular links have one crucial difference:
<a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> conversions for regular links <em>do not introduce a new error
into the error chain</em>, while conversions for foreign links <em>always
introduce a new error into the error chain</em>. So for the example
above all errors deriving from the <a href="https://doc.rust-lang.org/std/fmt/struct.Error.html"><code>std::fmt::Error</code></a> type will be
presented to the user as a new <a href="example_generated/enum.ErrorKind.html"><code>ErrorKind</code></a> variant, and the
cause will be the original <a href="https://doc.rust-lang.org/std/fmt/struct.Error.html"><code>std::fmt::Error</code></a> error. In contrast, when
<code>other_error::Error</code> is converted to <code>Error</code> the two <code>ErrorKind</code>s
are converted between each other to create a new <code>Error</code> but the
old error is discarded; there is no “cause” created from the
original error.</p>
<h3 id="backtraces"><a href="#backtraces">Backtraces</a></h3>
<p>If the <code>RUST_BACKTRACE</code> environment variable is set to anything
but <code>0</code>, the earliest non-foreign error to be generated creates
a single backtrace, which is passed through all <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> conversions
and <a href="example_generated/trait.ResultExt.html#tymethod.chain_err"><code>chain_err</code></a> invocations of compatible types. To read the
backtrace just call the <a href="struct.Backtrace.html"><code>backtrace</code></a> method.</p>
<p>Backtrace generation can be disabled by turning off the <code>backtrace</code> feature.</p>
<p>The Backtrace contains a Vec of <a href="https://docs.rs/backtrace/0.3.2/backtrace/struct.BacktraceFrame.html"><code>BacktraceFrame</code></a>s that can be operated
on directly.  For example, to only see the files and line numbers of code
within your own project.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Err</span>(<span class="kw-2">ref</span> <span class="ident">e</span>) <span class="op">=</span> <span class="ident">open_file</span>() {
    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">backtrace</span>) <span class="op">=</span> <span class="ident">e</span>.<span class="ident">backtrace</span>() {
        <span class="kw">let</span> <span class="ident">frames</span> <span class="op">=</span> <span class="ident">backtrace</span>.<span class="ident">frames</span>();
        <span class="kw">for</span> <span class="ident">frame</span> <span class="kw">in</span> <span class="ident">frames</span>.<span class="ident">iter</span>() {
            <span class="kw">for</span> <span class="ident">symbol</span> <span class="kw">in</span> <span class="ident">frame</span>.<span class="ident">symbols</span>().<span class="ident">iter</span>() {
                <span class="kw">if</span> <span class="kw">let</span> (<span class="prelude-val">Some</span>(<span class="ident">file</span>), <span class="prelude-val">Some</span>(<span class="ident">lineno</span>)) <span class="op">=</span> (<span class="ident">symbol</span>.<span class="ident">filename</span>(), <span class="ident">symbol</span>.<span class="ident">lineno</span>()) {
                    <span class="kw">if</span> <span class="ident">file</span>.<span class="ident">display</span>().<span class="ident">to_string</span>()[<span class="number">0</span>..<span class="number">3</span>] <span class="op">==</span> <span class="string">&quot;src&quot;</span>.<span class="ident">to_string</span>(){
                        <span class="macro">println!</span>(<span class="string">&quot;{}:{}&quot;</span>, <span class="ident">file</span>.<span class="ident">display</span>().<span class="ident">to_string</span>(), <span class="ident">lineno</span>);
                    }
                }
            }
        }
    }
};

<span class="kw">fn</span> <span class="ident">open_file</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
   <span class="ident">std::fs::File::open</span>(<span class="string">&quot;does_not_exist&quot;</span>)<span class="question-mark">?</span>;
   <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<h3 id="iteration"><a href="#iteration">Iteration</a></h3>
<p>The <a href="example_generated/struct.Error.html#method.iter"><code>iter</code></a> method returns an iterator over the chain of error boxes.</p>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="mod" href="example_generated/index.html" title="error_chain::example_generated mod">example_generated</a></div><div class="item-right docblock-short"><p>These modules show an example of code generated by the macro. <strong>IT MUST NOT BE
USED OUTSIDE THIS CRATE</strong>.</p>
</div></div></div><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.bail.html" title="error_chain::bail macro">bail</a></div><div class="item-right docblock-short"><p>Exits a function early with an error</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.ensure.html" title="error_chain::ensure macro">ensure</a></div><div class="item-right docblock-short"><p>Exits a function early with an error if the condition is not satisfied</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.error_chain.html" title="error_chain::error_chain macro">error_chain</a></div><div class="item-right docblock-short"><p>Macro for generating error types and traits. See crate level documentation for details.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.quick_main.html" title="error_chain::quick_main macro">quick_main</a></div><div class="item-right docblock-short"><p>Convenient wrapper to be able to use <code>?</code> and such in the main. You can
use it with a separated function:</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.stringify_internal.html" title="error_chain::stringify_internal macro">stringify_internal</a></div><div class="item-right docblock-short"><p>From https://github.com/tailhook/quick-error
Changes:</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.write_internal.html" title="error_chain::write_internal macro">write_internal</a></div><div class="item-right docblock-short"><p>Macro used interally for output expanding an expression</p>
</div></div></div><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Backtrace.html" title="error_chain::Backtrace struct">Backtrace</a></div><div class="item-right docblock-short"><p>Representation of an owned and self-contained backtrace.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.DisplayChain.html" title="error_chain::DisplayChain struct">DisplayChain</a></div><div class="item-right docblock-short"><p>A struct which formats an error for output.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Iter.html" title="error_chain::Iter struct">Iter</a></div><div class="item-right docblock-short"><p>Iterator over the error chain using the <code>Error::cause()</code> method.</p>
</div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.ChainedError.html" title="error_chain::ChainedError trait">ChainedError</a></div><div class="item-right docblock-short"><p>This trait is implemented on all the errors generated by the <code>error_chain</code>
macro.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.ExitCode.html" title="error_chain::ExitCode trait">ExitCode</a></div><div class="item-right docblock-short"><p>Represents a value that can be used as the exit status of the process.
See <a href="macro.quick_main.html"><code>quick_main!</code></a>.</p>
</div></div></div></section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="error_chain" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.60.0 (7737e0b5c 2022-04-04)" ></div>
</body></html>